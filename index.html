<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dude Generator</title>
  <style>
    html, body { margin: 0; background: black; overflow: hidden; }
    canvas { display: block;
  margin: auto;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); }
    #ui {
      position: absolute;
  top: calc(50% + 140px); /* unterhalb von 256x256 Canvas */
  left: 50%;
  transform: translateX(-50%);
  z-index: 10;
    }
    button {
      font-size: 16px;
      padding: 8px 12px;
      margin-right: 10px;
      background: #222;
      color: white;
      border: 1px solid #555;
      cursor: pointer;
    }
    html, body { margin: 0; background: #1a1a26; overflow: hidden; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>
</head>
<body>

<div id="ui">
  <button onclick="randomizeFigure()">🎲 Randomize Dude</button>
  <button onclick="startGifCapture()">🎥 Export GIF</button>
</div>

<script id="vertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;

uniform float u_time;
uniform vec2 u_resolution;
uniform vec4 u_blocks[64];
uniform vec3 u_colors[5];

varying vec2 vUv;

void main() {
  vec2 fragCoord = gl_FragCoord.xy;
  vec2 uv = fragCoord / u_resolution;
  vec3 col = vec3(0.1, 0.1, 0.15);

  vec2 base = vec2(0.25, 0.25); // <<< ZENTRIERUNG
  vec2 size = vec2(128.0) / u_resolution;
  vec2 localUV = (uv - base) / size * 16.0;
  vec2 puv = floor(localUV);

  int frame = int(mod(floor(u_time * 4.0), 2.0));

  for (int i = 0; i < 64; i++) {
    vec4 b = u_blocks[i];
    if (b.w < 0.5) continue;

    vec2 pos = b.xy;
    if (puv == pos || puv == vec2(15.0 - pos.x, pos.y)) {
      int zone = int(b.z);
      vec3 color = u_colors[zone];

      if (zone == 2) {
        bool isLeft = (int(pos.x) < 8);
        if ((frame == 0 && isLeft) || (frame == 1 && !isLeft)) {
          col = color;
        }
      } else {
        col = color;
      }
    }
  }

  gl_FragColor = vec4(col, 1.0);
}
</script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
const renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true });
renderer.setSize(256, 256);
document.body.appendChild(renderer.domElement);

const uniforms = {
  u_time: { value: 0 },
  u_resolution: { value: new THREE.Vector2(256, 256) },
  u_blocks: { value: Array.from({ length: 64 }, () => new THREE.Vector4(0, 0, 0, 0)) },
  u_colors: { value: [] }
};

function randomColor() {
  return new THREE.Color(Math.random(), Math.random(), Math.random());
}

function randomizeFigure() {
  const blocks = [];

  uniforms.u_colors.value = [
    randomColor(), // Kopf
    randomColor(), // Körper
    randomColor(), // Beine
    randomColor(), // Schuhe
    randomColor()  // Arme
  ];

  let i = 0;

  for (let y = 12; y <= 14; y++) {
    for (let x = 0; x <= 3; x++) {
      if (Math.random() > 0.3) {
        blocks[i++] = new THREE.Vector4(x + 6, y, 0, 1);
      }
    }
  }

  for (let y = 9; y <= 11; y++) {
    for (let x = 1; x <= 2; x++) {
      if (Math.random() > 0.25) {
        blocks[i++] = new THREE.Vector4(x + 6, y, 1, 1);
      }
    }
  }

  for (let y = 9; y <= 10; y++) {
    if (Math.random() > 0.3) blocks[i++] = new THREE.Vector4(5, y, 4, 1);
    if (Math.random() > 0.3) blocks[i++] = new THREE.Vector4(8, y, 4, 1);
  }

  for (let y = 4; y <= 6; y++) {
    blocks[i++] = new THREE.Vector4(5, y, 2, 1);
    blocks[i++] = new THREE.Vector4(9, y, 2, 1);
  }

  blocks[i++] = new THREE.Vector4(5, 3, 3, 1);
  blocks[i++] = new THREE.Vector4(9, 3, 3, 1);

  while (i < 64) blocks[i++] = new THREE.Vector4(0, 0, 0, 0);
  uniforms.u_blocks.value = blocks;
}

randomizeFigure();

const material = new THREE.ShaderMaterial({
  vertexShader: document.getElementById("vertexShader").textContent,
  fragmentShader: document.getElementById("fragmentShader").textContent,
  uniforms: uniforms
});

const plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
scene.add(plane);

let gifRecording = false;
let gif = null;
let gifFrame = 0;

function startGifCapture() {
  gifRecording = true;
  gifFrame = 0;

  gif = new GIF({
    workers: 2,
    quality: 10,
    width: 256,
    height: 256,
    workerScript: 'gif.worker.js'
  });

  gif.on('finished', blob => {
    const url = URL.createObjectURL(blob);

    const img = document.createElement("img");
    img.src = url;
    img.style.position = "absolute";
    img.style.top = "60px";
    img.style.left = "10px";
    img.style.border = "2px solid white";
    img.style.maxWidth = "200px";
    img.style.zIndex = 1000;
    document.body.appendChild(img);

    const a = document.createElement("a");
    a.href = url;
    a.download = "figure.gif";
    a.textContent = "⬇️ GIF herunterladen";
    a.style.position = "absolute";
    a.style.top = "270px";
    a.style.left = "10px";
    a.style.padding = "10px";
    a.style.background = "#222";
    a.style.color = "#fff";
    a.style.textDecoration = "none";
    document.body.appendChild(a);
  });
}

function animate(time) {
  requestAnimationFrame(animate);
  uniforms.u_time.value = time * 0.001;
  renderer.render(scene, camera);

  if (gifRecording) {
    gif.addFrame(renderer.domElement, { copy: true, delay: 33 });
    gifFrame++;
    if (gifFrame >= 90) {
      gifRecording = false;
      gif.render();
    }
  }
}

animate();
</script>

</body>
</html>
